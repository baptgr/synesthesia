## Synesthesia — Implementation Plan (Simplified MVP)

### Scope Alignment
- Random song playback from a curated set of mp3 files.
- User enters a thought/prompt; click Generate to produce an image via Flux models (BFL).
- Show images generated by other users for the same song (per-track gallery), with prompt visible on card.
- No sharing links, no admin UI, no rate limiting in MVP.

---

## Milestones
1) Project bootstrap (repo, Flask skeleton, vanilla JS scaffold)
2) Supabase setup (buckets + minimal schema)
3) Backend APIs (random track, generate, list generations)
4) Frontend (audio player, prompt input, generate flow, per-track gallery)
5) Flux integration (server-side, store output in Supabase Storage)
6) Deployment (Fly.io) and smoke tests

---

## 1) Project Bootstrap
- Initialize Python project with Flask and Gunicorn.
- Create basic structure:
```
/synesthesia
  /app
    __init__.py
    routes.py
    services/
      bfl.py       # Flux API client
      supabase.py  # DB + Storage helpers
    static/
      css/
      js/
      img/
    templates/
      index.html
  requirements.txt
  runtime.txt (optional)
  Dockerfile
  fly.toml (later)
  .env (local only)
```
- Requirements (initial): `flask`, `gunicorn`, `supabase`, `requests`, `python-dotenv`.

Acceptance criteria:
- Local server starts; serves a simple index page.

---

## 2) Supabase Setup
- Create project (if not already).
- Storage buckets:
  - `tracks` (mp3 assets)
  - `generated-images` (image outputs)
- Database tables (minimal):
  - `tracks`
    - `id` (uuid, pk)
    - `title` (text)
    - `artist` (text)
    - `created_at` (timestamptz, default now())
  - `generations`
    - `id` (uuid, pk)
    - `track_id` (uuid, fk → tracks.id)
    - `prompt_text` (text)
    - `image_url` (text)
    - `created_at` (timestamptz, default now())
- Audio file convention: Upload `tracks/{track_id}.mp3` so audio URL can be derived from `track_id`.

Acceptance criteria:
- Buckets exist; at least 3 mp3s uploaded and mapped via `track_id`.
- Tables created; can insert/select rows.

---

## 3) Backend APIs (Flask)
- Environment variables: `SUPABASE_URL`, `SUPABASE_SERVICE_KEY`, `SUPABASE_ANON_KEY` (optional client), `BFL_API_KEY`, `FLASK_SECRET_KEY`.
- Helpers:
  - Supabase client for Postgres queries and Storage operations.
  - Signed URL generation for `tracks/{track_id}.mp3` and `generated-images/{id}.png`.
- Endpoints:
  - `GET /api/tracks/random`
    - Select random row from `tracks`.
    - Build signed audio URL from `tracks/{track_id}.mp3`.
    - Return `{ id, title, artist, audioUrl }`.
  - `GET /api/generations?trackId=<uuid>&limit=<n>&offset=<m>`
    - Return recent generations for the track: `{ id, imageUrl, promptText, createdAt }`.
  - `POST /api/generate`
    - Body: `{ prompt: string, trackId: uuid }`.
    - Call Flux API with prompt; receive image bytes.
    - Upload to `generated-images/{generation_id}.png`.
    - Insert row in `generations` with public/signed URL.
    - Return `{ generationId, imageUrl }`.

Acceptance criteria:
- All endpoints return expected shapes; errors handled with clear messages.

---

## 4) Frontend (Vanilla JS)
- `index.html`:
  - Start button (to satisfy autoplay policies).
  - Track info (title, artist), audio element with Play/Pause, Next.
  - Prompt input + Generate button + loading indicator.
  - Gallery grid showing images for current track; clicking card reveals prompt (tooltip or simple overlay).
- `main.js`:
  - On Start: fetch `/api/tracks/random`, set audio source to `audioUrl`, autoplay.
  - On Next: refetch `/api/tracks/random`, switch track and refresh gallery.
  - On Generate: POST `/api/generate`; on success, prepend image to gallery.
  - On track change: GET generations for `trackId` and render grid.

Acceptance criteria:
- Can listen to a random track; can change track; can generate image and see it in gallery.

---

## 5) Flux Integration (BFL)
- Server-side client in `services/bfl.py` using `BFL_API_KEY`.
- Synchronous generation for MVP (e.g., 768x768).
- Return raw image bytes; backend uploads to Supabase Storage and stores URL in DB.
- Handle timeouts and API errors gracefully.

Acceptance criteria:
- End-to-end: Prompt → Flux → Image stored → Gallery updates.

---

## 6) Deployment (Fly.io)
- `Dockerfile` using Python base image; install requirements; run Gunicorn (`web: gunicorn app:app` or factory pattern).
- `fly launch` to create `fly.toml`.
- Set secrets: `fly secrets set BFL_API_KEY=... SUPABASE_URL=... SUPABASE_SERVICE_KEY=... FLASK_SECRET_KEY=...`.
- `fly deploy`.

Acceptance criteria:
- Public URL serves the app; generation works with Supabase and BFL.

---

## QA Checklist
- Audio: Start button required; Play/Pause works; Next track fetches new audio.
- Generation: Loading state visible; errors show friendly message; success updates gallery.
- Gallery: Loads recent images for current track; prompts visible; pagination optional.
- Resilience: Empty gallery state handled; missing mp3 handled with retry/Next.

---