## Synesthesia — Product Requirements Document (PRD)

### Overview
Synesthesia is a simple web app where a randomly selected song is played, the user writes what it makes them think of, clicks a button, and that text is transformed into an image via an image generation model. Users can also view all images generated by others for the same song.

- **Tech stack**: Flask (backend), vanilla JavaScript (frontend), Flux models via Black Forest Labs APIs for image generation, Supabase (Postgres + Storage), deployed on Fly.io.
- **Guiding principle**: Keep it simple; fast path to first image.

### Goals
- **Simple MVP**: Minimal UI and flows; no heavy auth or social features.
- **Fast “time-to-first-image”**: Under 60 seconds from landing to image.
- **Low-cost operation**: Rate limits and usage caps to protect budget.
- **Track-based galleries**: Users can see images from others for the currently playing track.

### Non-Goals
- **Complex social graph** (follows, comments threads, DMs).
- **Mobile apps** (web only, responsive design is sufficient).
- **Advanced playlist management** (admin-only track curation, no public uploads in MVP).
- **Full user accounts** (anonymous session with optional nickname only).

## User Stories
- As a visitor, I can click “Start” to enable audio and play a random track.
- As a visitor, while a track plays, I can type a thought/prompt and click “Generate” to produce an image.
- As a visitor, I can view a gallery of images generated by others for the same track.
- As a visitor, I can skip to a different random track if I’m not inspired.

## Key Flows
1) Landing → Click “Start” (enables audio due to browser autoplay policies) → Random track begins playing → Prompt input → Click “Generate” → Spinner → Image appears + Images from other people

2) Gallery → Displays grid of recent images for current track (by created time) → Click a card to view prompt 

3) Skip → From player controls, choose Next → New random track (audio continues).

## Functional Requirements
### Audio & Tracks
- **Random track selection**: Endpoint returns one active track at random.
- **Playback**: HTML5 `<audio>` for mp3 sources; YouTube iframe embed as fallback (if mp3 list is unavailable or optional configuration prefers YT).
- **Autoplay constraints**: Require explicit “Start” button click to initiate sound.
- **Basic controls**: Play/Pause, Next (fetches another random track), Track title/artist display.
- **Track sources**:
  - mp3 stored in Supabase Storage (preferred for control and reliability), or
  - YouTube link stored as `source_url` with `source_type = 'youtube'`.

### Prompt & Generation
- **Prompt input**: Single text field with placeholder (“What does this song make you see?”), submit via button or Enter.
- **Generation call**: POST to backend with `{ prompt, trackId }`. Backend calls Flux model API.
- **Generation mode**: Synchronous request/response for MVP. Show spinner/state during call, with 60s timeout.
- **Parameters**: Default resolution 768x768, reasonable inference settings; seed optional; default negative prompt optional for quality.
- **Results**: On success, backend stores metadata + image in Supabase and returns `imageUrl` and `generationId`.

## Non-Functional Requirements
- **Performance**: Initial page load under 2s on typical broadband; image generation under 60s.
- **Reliability**: Handle generation failures gracefully with clear retry CTA.
- **Security**: API keys in server-side env; signed URLs for Storage; basic CORS.
- **Privacy**: No PII collected by default. Anonymous sessions; optional nickname.

## Architecture
- **Frontend**: Single-page experience built with vanilla JS and minimal HTML/CSS; communicates with Flask JSON APIs.
- **Backend**: Flask app serving static assets + JSON routes; calls BFL Flux API; stores results in Supabase.
- **Database & Storage**: Supabase Postgres for metadata; Supabase Storage for mp3s and generated images.
- **Deployment**: Fly.io app running Gunicorn + Flask; one small instance; stateless (no local persistence).

```
Browser (JS)
  ↕ JSON
Flask API (Fly.io)
  ↔ Supabase (Postgres + Storage)
  ↔ Black Forest Labs (Flux models API)
```

## Data Model (Supabase)
### Tables
- **tracks**
  - id (uuid, pk)
  - title (text, not null)
  - artist (text)
  - created_at (timestamptz, default now())

- **generations**
  - id (uuid, pk)
  - track_id (uuid, fk → tracks.id, not null)
  - prompt_text (text, not null)
  - image_url (text, not null) — signed URL or public path
  - created_at (timestamptz, default now())

### Storage Buckets
- `tracks` — mp3 assets
- `generated-images` — image outputs. Prefer private bucket with signed delivery.

## APIs (Flask)
- `GET /` — Serve landing page and static assets.
- `GET /api/tracks/random` — Returns `{ id, title, artist, source_type, source_url }` for a random active track.
- `POST /api/generate` — Body: `{ prompt: string, trackId: uuid }` → Calls Flux API → Stores image + metadata → Returns `{ generationId, imageUrl }`.
- `GET /api/generations?trackId=<uuid>&limit=<n>&offset=<m>` — Returns list of generations for the track.
- `GET /g/<generationId>` — Server-rendered/detail route showing single generation (or client route consuming JSON under the hood).

### Request/Response Contracts (Examples)
- Generate request:
```
POST /api/generate
{
  "prompt": "glittering city at dusk, saxophone echoes",
  "trackId": "b45f9e2e-..."
}
```
- Generate response (success):
```
200 OK
{
  "generationId": "b3a2...",
  "imageUrl": "https://.../signed/url.png"
}
```
- Generate response (error):
```
502 Bad Gateway
{
  "error": "generation_failed"
}
```

## Image Generation (Flux Models)
- **Provider**: Black Forest Labs (Flux). See pricing and model catalog at `https://bfl.ai/pricing?category=flux+models`.
- **API usage**: Server-side only. Store API key as env var. Send prompt, desired resolution (768x768), and optional seed.
- **Synchronous MVP**: Call API and wait for image; set generous timeout (e.g., 60s). On success, upload image bytes to Supabase Storage and store the public/signed URL in `generations.image_url`.
- **Fallbacks**: On timeout or error, return proper error response and surface retry CTA.

## Frontend
- **Pages/Views**:
  - Landing/Player: Start button, track info, audio controls, prompt input, Generate button, Spinner, Result image, CTA to view Gallery.
  - Gallery (per track): Grid of image cards, Load more.
  - Generation detail: Full image view with prompt and track info.
- **Components**:
  - PlayerBar (title/artist, Play/Pause, Next)
  - PromptBox (input + generate button)
  - ImageCard (thumbnail, prompt excerpt)
  - GalleryGrid (paginated)
- **State**:
  - Current track
  - Loading/generation state
  - Recent generations list for track
  - Anonymous `sessionId` (cookie)

## Environment & Configuration
- `FLASK_ENV`, `FLASK_SECRET_KEY`
- `BFL_API_KEY` (Flux)
- `SUPABASE_URL`, `SUPABASE_ANON_KEY` (client reads), `SUPABASE_SERVICE_KEY` (server writes)
- `RATE_LIMIT_DAILY_PER_IP` (default 20), `RATE_LIMIT_DAILY_PER_SESSION` (default 20)

## Deployment (Fly.io)
- **Runtime**: Gunicorn serving Flask.
- **Scale**: Single shared-CPU instance for MVP.
- **Config**: Dockerfile or `fly.toml` using Python builder; mount no persistent volumes (stateless).
- **Secrets**: Set via `fly secrets set` for API keys and Supabase service key.
- **CD**: Manual `fly deploy` from main branch for MVP.
